type ERC3000Registry @entity {
  id: ID!
  address: Bytes!
  count: Int!
  entries: [RegistryEntry!]!
}

type RegistryEntry @entity {
  id: ID!
  name: String!
  queue: GovernQueue!
  executor: Govern!
}

type Govern @entity {
  id: ID!
  address: Bytes!
  metadata: Bytes
  registryEntries: [RegistryEntry!]! @derivedFrom(field: "executor")
  containers: [Container]!
  roles: [Role!]!
}

type GovernQueue @entity {
  id: ID!
  address: Bytes!
  config: Config!
  registryEntries: [RegistryEntry!]! @derivedFrom(field: "queue")
  queued: [Container!]!
  roles: [Role!]!
}

type Config @entity {
  id: ID!
  queue: GovernQueue!
  executionDelay: BigInt!
  scheduleDeposit: Collateral!
  challengeDeposit: Collateral!
  vetoDeposit: Collateral!
  resolver: Bytes!
  rules: Bytes!
}

type Container @entity {
  id: ID!
  queue: GovernQueue! @derivedFrom(field: "queued")
  state: ContainerState!
  config: Config!
  payload: ContainerPayload!
  history: [ContainerEvent]!
}

type ContainerPayload @entity {
  id: ID!
  container: Container! @derivedFrom(field: "payload")
  nonce: BigInt!
  executionTime: BigInt!
  submitter: Bytes!
  executor: Govern!
  actions: [Action!]! @derivedFrom(field: "payload")
  allowFailuresMap: Bytes!
  proof: Bytes!
}

type ContainerEvent @entity {
  id: ID!
  type: ContainerEventType
  createdAt: BigInt
  data: [String!]!
}

type Collateral @entity {
  id: ID!
  token: Bytes!
  amount: BigInt!
}

type Action @entity {
  id: ID!
  payload: ContainerPayload!
  to: Bytes!
  value: BigInt!
  data: Bytes!
}

type Role @entity {
  id: ID!
  entity: Bytes!
  selector: Bytes!
  who: Bytes!
  granted: Boolean!
  frozen: Boolean!
}

enum ContainerEventType {
  Challenge
  Execute
  Resolve
  Rule
  Schedule
  SubmitEvidence
  Veto
}

enum ContainerState {
  None
  Scheduled
  Approved
  Challenged
  Rejected
  Cancelled
  Executed
}
